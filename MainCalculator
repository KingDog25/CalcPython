import tkinter as tk
from math import sin, cos, tan, sinh, log10, sqrt


class Calculator:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Стандартный калькулятор")
        self.history = []
        self.engineer_mode = False  # Определить engineer_mode здесь
        self.last_operations = []
        self.mod_flag = False
        self.mod_value = None
        self.y_root_flag = False
        self.y_root_value = None

        # Инициализировать память после определения engineer_mode
        self.memory = [0, 0] if self.engineer_mode else [0]

        # Дисплей
        self.display_frame = tk.Frame(self.root)
        self.display_frame.grid(row=0, column=0, columnspan=4, sticky="nsew")

        if not self.engineer_mode:
            self.display = tk.Entry(self.display_frame, width=35, borderwidth=5, font=("Arial", 14))
            self.display.pack(fill="both", expand=True)
            self.display.insert(0, "0")
        else:
            self.history_display = tk.Text(self.display_frame, height=2, width=35,
                                           borderwidth=5,
                                           font=("Arial", 14))
            self.history_display.pack(fill="x")
            self.history_display.insert(tk.END, "")

            self.input_display = tk.Entry(self.display_frame,
                                          width=35,
                                          borderwidth=5,
                                          font=("Arial", 14))
            self.input_display.pack(fill="x")
            self.input_display.insert(0, "0")

        # Кнопки
        self.buttons_frame = tk.Frame(self.root)
        self.buttons_frame.grid(row=1, column=0, columnspan=4, sticky="nsew")

        buttons_grid = [
            ['C', 'CE', '\u2190', 'Инж.' if not self.engineer_mode else 'Stand'],
            ['MC1', 'M+', 'M-', 'MR'],
            ['MC2', 'M+', 'M-', 'MR'] if self.engineer_mode else [],
            ['7', '8', '9', '+'],
            ['4', '5', '6', '-'],
            ['1', '2', '3', '*'],
            ['0', '.', '\u221A' if not self.engineer_mode else 'lg10', '/'],
            ['+/-', 'x^y', '1/x', '\u221A' if self.engineer_mode else '='],
            ['y√x', 'sinh', 'mod', '='] if self.engineer_mode else []
        ]

        colors = {
            'C': 'red',
            'CE': 'red',
            '\u2190': '#474eff',
            '+': 'orange',
            '-': 'orange',
            '*': 'orange',
            '/': 'orange',
            '=': 'orange',
            '+/-': 'orange',
            'x^y': 'orange',
            '1/x': 'orange',
            'Инж.': '#21b030',
            'Stand': '#21b030',
            '\u221A': 'orange',
            '.': 'orange',
            'lg10': 'orange',
            'y√x': 'orange',
            'sinh': 'orange',
            'mod': 'orange'
        }

        for i, row in enumerate(buttons_grid):
            for j, text in enumerate(row):
                color = colors.get(text, 'lightblue')
                if text.isdigit():
                    color = 'lightgray'

                btn = tk.Button(self.buttons_frame, text=text, bg=color, font=("Arial", 14))
                btn.config(command=lambda text=text: self.button_pressed(text))
                btn.grid(row=i, column=j, sticky="nsew")

        # Увеличение кнопок при растягивании экрана
        for i in range(4):
            self.buttons_frame.grid_columnconfigure(i, weight=1)

        # Configure rows only if they are used
        for i in range(len(buttons_grid)):
            if any(buttons_grid[i]):
                self.buttons_frame.grid_rowconfigure(i, weight=1)

        self.root.grid_columnconfigure(0, weight=1)
        self.root.grid_rowconfigure(0, weight=2)
        self.root.grid_rowconfigure(1, weight=3)

        self.update_font_size()
        self.validate_input()

    def validate_input(self):
        current_value = self.get_current_value()
        valid_chars = '0123456789+-*/.()**\u221A\u2190lg10sinhmody√^='

        # Проверка на последовательные операции
        if len(current_value) > 1 and current_value[-1] in '+-*/^' and current_value[-2] in '+-*/^':
            self.clear_display()
            self.insert_to_display(current_value[:-1])

        if not all(char in valid_chars for char in current_value):
            self.clear_display()
            self.insert_to_display(''.join(char for char in current_value if char in valid_chars))

        self.root.after(100, self.validate_input)

    def update_font_size(self):
        width = self.get_display().winfo_width()
        height = self.get_display().winfo_height()

        if width > 0 and height > 0:
            font_size = min(width // 20, height // 5)
            if self.engineer_mode:
                self.history_display.config(font=("Arial", max(10, font_size)))
                self.input_display.config(font=("Arial", max(10, font_size)))
            else:
                self.display.config(font=("Arial", max(10, font_size)))

        self.root.after(100, self.update_font_size)

    def get_current_value(self):
        return self.input_display.get() if self.engineer_mode else self.display.get()

    def clear_display(self):
        (self.input_display if self.engineer_mode else self.display).delete(0, tk.END)

    def insert_to_display(self, text):
        (self.input_display if self.engineer_mode else self.display).insert(tk.END, text)

    def get_display(self):
        return self.input_display if self.engineer_mode else self.display

    def button_pressed(self, text):
        current_value = self.get_current_value()

        if text == '=':
            try:
                current_value = current_value.replace('^', '**')
                if self.mod_flag:
                    result = int(self.mod_value) % int(current_value.split('mod')[-1])
                    self.history.append(f"{int(self.mod_value)} % {int(current_value.split('mod')[-1])} = {result}")
                    self.clear_display()
                    self.insert_to_display(str(result))
                    self.mod_flag = False
                    if self.engineer_mode:
                        self.update_history_display()
                elif self.y_root_flag:
                    result = float(current_value.split('y√')[-1]) ** (1 / self.y_root_value)
                    self.history.append(f"{self.y_root_value}√{current_value.split('y√')[-1]} = {result}")
                    self.clear_display()
                    self.insert_to_display(str(result))
                    self.y_root_flag = False
                    if self.engineer_mode:
                        self.update_history_display()
                else:
                    result = eval(current_value)
                    self.history.append(f"{current_value} = {result}")
                    self.clear_display()
                    self.insert_to_display(str(result))
                    if self.engineer_mode:
                        self.update_history_display()
            except Exception as e:
                self.clear_display()
                self.insert_to_display("Ошибка")
                if self.engineer_mode:
                    self.history_display.delete("1.0", tk.END)
                    self.history_display.insert(tk.END,
                                                f"Ошибка\n")

        elif text == 'C':
            self.clear_display()
            self.history.clear()
            if self.engineer_mode:
                self.history_display.delete("1.0", tk.END)
            self.insert_to_display("0")

        elif text == 'CE':
            self.clear_display()
            self.insert_to_display("0")

        elif text == '\u2190':
            if len(current_value) > 1:
                self.clear_display()
                self.insert_to_display(current_value[:-1])
            else:
                self.clear_display()
                self.insert_to_display("0")

        elif text == '+/-':
            if current_value[0] != '-':
                self.clear_display()
                self.insert_to_display('-' + current_value)
            else:
                self.clear_display()
                self.insert_to_display(current_value[1:])

        elif text == 'x^y':
            self.insert_to_display('^')

        elif text == '1/x':
            try:
                result = 1 / float(current_value)
                self.history.append(f"1/{current_value}={result}")
                self.clear_display()
                self.insert_to_display(str(result))
                if self.engineer_mode:
                    self.update_history_display()
            except ZeroDivisionError:
                self.clear_display()
                self.insert_to_display("Ошибка")
                if self.engineer_mode:
                    self.history_display.delete("1.0", tk.END)
                    self.history_display.insert(tk.END,
                                                f"Ошибка\n")

        elif text == '\u221A' or text == 'lg10':
            try:
                result = sqrt(float(current_value)) if text == '\u221A' else log10(float(current_value))
                log_text = f"log({current_value})={result}" if text == 'lg10' else f"{text}{current_value}={result}"
                self.history.append(log_text)
                self.clear_display()
                self.insert_to_display(str(result))
                if self.engineer_mode:
                    self.update_history_display()
            except ValueError:
                self.clear_display()
                self.insert_to_display("Ошибка")
                if self.engineer_mode:
                    self.history_display.delete("1.0", tk.END)
                    self.history_display.insert(tk.END,
                                                f"Ошибка\n")

        elif text.startswith('MC'):
            index = int(text[-1]) - 1
            if index < len(self.memory):
                self.memory_clear(index)
                if self.engineer_mode:
                    self.update_history_display(f"MC{index + 1}=0")

        elif text == 'M+':
            try:
                value_to_add = float(current_value)
                for i in range(len(self.memory)):
                    self.memory[i] += value_to_add
                if self.engineer_mode:
                    for i in range(len(self.memory)):
                        self.update_history_display(f"M+{i + 1}={self.memory[i]}")
            except ValueError:
                self.clear_display()
                self.insert_to_display("Ошибка")

        elif text == 'M-':
            try:
                value_to_subtract = float(current_value)
                for i in range(len(self.memory)):
                    self.memory[i] -= value_to_subtract
                if self.engineer_mode:
                    for i in range(len(self.memory)):
                        self.update_history_display(f"M-{i + 1}={self.memory[i]}")
            except ValueError:
                self.clear_display()
                self.insert_to_display("Ошибка")


        elif text == 'MR':
            try:
                index_to_recall = int(current_value) - 1 if current_value.isdigit() else 0
                if index_to_recall < len(self.memory):
                    result_to_recall = str(self.memory[index_to_recall])
                    self.clear_display()
                    self.insert_to_display(result_to_recall)
            except (ValueError, IndexError):
                self.clear_display()
                self.insert_to_display("Ошибка")

        elif text == 'mod':
            self.mod_flag = True
            self.mod_value = float(current_value)
            self.insert_to_display('mod')

        elif text == 'y√x':
            self.y_root_flag = True
            self.y_root_value = float(current_value)
            self.insert_to_display('y√')

        elif text == 'sinh':
            try:
                result = sinh(float(current_value))
                self.history.append(f"sinh({current_value})={result}")
                self.clear_display()
                self.insert_to_display(str(result))
                if self.engineer_mode:
                    self.update_history_display()
            except Exception as e:
                self.clear_display()
                self.insert_to_display("Ошибка")
                if self.engineer_mode:
                    self.history_display.delete("1.0", tk.END)
                    self.history_display.insert(tk.END,
                                                f"Ошибка\n")

        elif text == 'Инж.' or text == 'Stand':
            self.engineer_mode = not self.engineer_mode

            for widget in self.buttons_frame.winfo_children():
                widget.destroy()

            buttons_grid = [
                ['C', 'CE', '\u2190', 'Инж.' if not self.engineer_mode else 'Stand'],
                ['MC1', 'M+', 'M-', 'MR'],
                ['MC2', 'M+', 'M-', 'MR'] if self.engineer_mode else [],
                ['7', '8', '9', '+'],
                ['4', '5', '6', '-'],
                ['1', '2', '3', '*'],
                ['0', '.', '\u221A' if not self.engineer_mode else 'lg10', '/'],
                ['+/-', 'x^y', '1/x', '\u221A' if self.engineer_mode else '='],
                ['y√x', 'sinh', 'mod', '='] if self.engineer_mode else []
            ]

            colors = {
                'C': 'red',
                'CE': 'red',
                '\u2190': '#474eff',
                '+': 'orange',
                '-': 'orange',
                '*': 'orange',
                '/': 'orange',
                '=': 'orange',
                '+/-': 'orange',
                'x^y': 'orange',
                '1/x': 'orange',
                'Инж.': '#21b030',
                'Stand': '#21b030',
                '\u221A': 'orange',
                '.': 'orange',
                'lg10': 'orange',
                'y√x': 'orange',
                'sinh': 'orange',
                'mod': 'orange'
            }

            for i, row in enumerate(buttons_grid):
                for j, t in enumerate(row):
                    color = colors.get(t, 'lightblue')
                    if t.isdigit():
                        color = 'lightgray'

                    btn = tk.Button(self.buttons_frame, text=t, bg=color, font=("Arial", 14))
                    btn.config(command=lambda t=t: self.button_pressed(t))
                    btn.grid(row=i, column=j, sticky="nsew")

            # Двухстрочный дисплей инженерного калькулятора с историей операций и новым вводом.
            for widget in self.display_frame.winfo_children():
                widget.destroy()

            if not self.engineer_mode:
                self.display = tk.Entry(self.display_frame,
                                        width=35,
                                        borderwidth=5,
                                        font=("Arial", 14))
                self.display.pack(fill="both", expand=True)
                self.display.insert(0, "0")
                self.root.title("Стандартный калькулятор")
                self.memory = [0]
            else:
                self.history_display = tk.Text(self.display_frame,
                                               height=2,
                                               width=35,
                                               borderwidth=5,
                                               font=("Arial", 14))
                self.history_display.pack(fill="x")
                self.history_display.insert(tk.END, "")

                self.input_display = tk.Entry(self.display_frame,
                                              width=35,
                                              borderwidth=5,
                                              font=("Arial", 14))
                self.input_display.pack(fill="x")
                self.input_display.insert(0, "0")
                self.root.title("Инженерный калькулятор")
                self.memory = [0, 0]

        else:
            if current_value == "0" and text in "+-*/":
                try:
                    result = eval("0" + text + "3")
                    self.clear_display()
                    self.insert_to_display(str(int(result)))
                except Exception as e:
                    self.clear_display()
                    self.insert_to_display("Ошибка")
                    if self.engineer_mode:
                        self.history_display.delete("1.0", tk.END)
                        self.history_display.insert(tk.END,
                                                    f"Ошибка\n")
            elif current_value == "0" and text != '.':
                self.clear_display()
            self.insert_to_display(text)

    def memory_clear(self, index):
        if index < len(self.memory):
            self.memory[index] = 0

    def memory_add(self, index, value):
        try:
            if index < len(self.memory):
                self.memory[index] += float(value)
        except ValueError:
            self.clear_display()
            self.insert_to_display("Ошибка")

    def memory_subtract(self, index, value):
        try:
            if index < len(self.memory):
                self.memory[index] -= float(value)
        except ValueError:
            self.clear_display()
            self.insert_to_display("Ошибка")

    def memory_recall(self, index):
        try:
            result = str(self.memory[index])
            self.clear_display()
            self.insert_to_display(result)
        except IndexError:
            self.clear_display()
            self.insert_to_display("Ошибка")

    def update_history_display(self, message=None):
        if message is not None:
            self.history.append(message)

        self.history_display.delete("1.0", tk.END)

        if len(self.history) > 1:
            self.history_display.insert(tk.END,
                                        self.history[-2] + "\n")

        self.history_display.insert(tk.END,
                                    self.history[-1])

    def run(self):
        self.root.mainloop()


if __name__ == "__main__":
    calc = Calculator()
    calc.run()

